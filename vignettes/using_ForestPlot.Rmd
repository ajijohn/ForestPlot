---
title: "ForestPlot"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ForestPlot}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The ForestPlot R package is designed to facilitate the cleaning, analysis and
visualization of mapped forest plot data.

In this vignette we: (1) describe the intended use cases of ForestPlot, (2)
explain how datasets need to be formatted to be compatible with ForestPlot
functions, and (3) use the built-in datasets to demonstrate each included
function.


```{r setup, warning = FALSE, message = FALSE}
library(ForestPlot)
library(dplyr)
```

## Intended uses of ForestPlot

In mapped forest plots, the precise locations of individual trees are recorded.
This means that for any location within the plot, we can describe the local tree
community in a spatially explicit way by identifying the size, proximity and 
species identity of nearby trees. These descriptions are termed neighborhoods
and can be used as covariates in models of forest processes such as tree
growth/mortality or nutrient cycling. The main goal of ForestPlot is to provide
functions that can efficiently quantify and explore these neighborhoods. 

Specific questions ForestPlot could be used to answer:

* How are growth/survival rates of trees influenced by neighboring trees?
* What is the relationship between soil microbial community composition and
tree neighborhood?
* Where in this mapped stand is tree density the lowest?

## Data formatting requirements

rectangular plots only

separation between mapping and tree

structure of mapping and tree

column names of mapping and tree



## Data checking

Missing or inaccurate data is a common occurrence in mapping and tree census
datasets because of the challenging field conditions under which the data are
collected. Some trees must therefore be excluded from certain analyses. To help
with the data checking process, this package contains two functions,
`mapping_check` and `tree_check`, that flag cases of missing data in mapping and
tree census datasets respectively. As the seriousness of missing data will vary
among analytical approaches, these functions do not remove any observations.
Instead they flag observations that should be investigated further before
starting analysis.

### `mapping_check()`: Check tree mapping datasets

The built-in dataset `messy_mapping` contains examples of common data errors in
mapping datasets. For instance, there are 10 tree ids that are connected to more
than one mapping record:

```{r}
messy_mapping %>%
  group_by(tree_id) %>%
  summarize(count = n()) %>%
  filter(count > 1)
```

The `mapping_check` function checks a mapping dataset for a variety of common
errors and returns a list containing two elements. The first element is a data
frame containing the rows of the input mapping dataset that contain issues, with
an additional final column describing the issue. The arguments "max_x" and 
"max_y" must be provided so the function can check for x and y coordinates
beyond the plot boundary (remember any such trees will only be flagged, not
removed from the dataset automatically).

```{r}
map_issues <- mapping_check(messy_mapping, max_x = 100, max_y = 100)
head(map_issues$problem_trees)
```

The second element is a data frame summarizing the number and percentage of
trees in the mapping dataset that have one or more problems and each specific
type of problem.

```{r}
head(map_issues$issue_summary)
```

### `tree_check()`: Check tree census datasets

The built-in dataset `messy_tree` contains examples of common data errors in
tree census datasets. For instance, there are 10 tree measurement records that
have no dbh information:

```{r}
messy_tree %>%
  filter(is.na(dbh))
```

The `tree_check` function checks a tree census dataset for a variety of common
errors. A mapping dataset needs to be supplied to the function so that trees in
the tree census data that have no associated mapping can be identified. 
`tree_check` returns a list containing two elements. The first element is a data
frame containing the tree ids that were flagged as having a data issue and 
summarizes the issue.

```{r}
tree_issues <- tree_check(tree_data = messy_tree, map_data = mapping)
head(tree_issues$problem_trees)
```

The second element is a data frame summarizing the number and percentage of
trees in the tree census dataset that have one or more problems and each
specific type of problem. Note that a tree id will be flagged if just one of
its measurement records contains an issue, so many flagged trees are likely to
be usable for most analyses. 

```{r}
head(tree_issues$issue_summary)
```

## Quantifying neighborhoods



### `neighborhoods()`: Extract neighborhoods

The `neighborhoods()` function uses a mapping dataset to determine, for each
tree, all the trees that are within a certain distance (`radius`). The argument
`stand` can be used to indicate that neighborhoods should be constructed only
for the trees of one or more of the stands included in `mapping`. If `stand` is
not specified, neighborhoods will be constructed for all trees in `mapping`.

The output is a data frame where each row contains information on a focal tree
and one other tree growing in the focal tree's neighborhood. Therefore, the
information for each focal tree will appear on `x` lines, where `x` is the
number of trees in that focal tree's neighborhood. This structure is shown
below by isolating a single focal tree in the output.

```{r}
nbhds <- neighborhoods(mapping, stand = "AB08", radius = 10)
nbhds %>%
  filter(tree_id == "AB08000100022")
```

The `neighborhoods()` function can also be used to construct neighborhoods for
specific coordinates within the mapped plot instead of constructing a
neighborhood centered on each tree in the dataset. This is achieved by
providing a data frame of coordinates under the optional argument `coords` (see
function documentation for details on how this data frame should be structured).

```{r}
# Create a data frame of coordinates
locations <- data.frame(
  loc_id = paste("A", 1:81, sep = ""),
  x_coord = rep(seq(10, 90, 10), times = 9),
  y_coord = rep(seq(10, 90, 10), each = 9))

# Construct neighborhood for each coordinate
coord_nbhds <- neighborhoods(mapping, stands = "AB08", radius = 10,
                             coords = locations)
head(coord_nbhds)
```

### `neighborhood_summary()`: Summarize neighborhoods

The `neighborhood_summary()` function takes a neighborhoods object output by
the `neighborhoods()` function and calculates summary statistics for each
neighborhood. These statistics are species richness, overall tree density, and
densities of each tree species. The `densities` argument can be used to specify
how densities should be calculated:

* `densities = "raw"` - m^2 per hectare
* `densities = "proportional"` - species-specific densities are proportions of
overall tree density
* `densities = "angular"` - sum of angles occupied by neighboring trees

The argument `id_column` specifies the name of the column that uniquely 
identifies each neighborhood, which should be `tree_id` if neighborhoods were
centered on trees or the name of the column containing site names in the
`coords` data frame passed to `neighborhoods()`. For accurate measurement of
densities it is critical that `radius` is equal to the `radius` argument passed
to `neighborhoods()`.

Below is a excerpt of the output of `neighborhood_summary()` applied to the
`nbhds` data frame created above.

```{r}
nbhd_summ <- neighborhood_summary(nbhds, id_column = "tree_id", radius = 10,
                                  densities = "angular")
head(nbhd_summ)
```

